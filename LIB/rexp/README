




REXP  日本語対応高速正規表現ライブラリ


●概要

        　rexp は有限オートマトンを利用した，日本語対応正規表現ライブラリ
        です．正規表現を非決定性有限オートマトン（NFA）にコンパイルし，照
        合実行時に決定性有限オートマトン（DFA）の状態遷移表を暫時作りなが
        ら検索するので，バックトラックしながら照合を行うものに比べて非常
        に高速なのが特徴です．また，メタキャラクタを含まない表現を検索す
        る場合には，自動的に Boyer-Moore アルゴリズムに切り替え，さらに高
        速な検索を可能にしています（メタキャラクタを含んでいる場合も，Bo
        yer-Moore アルゴリズムを併用して高速化を図っています）．サポート
        している正規表現は，現時点でタグ付き表現がインプリメントされてい
        ない以外は，拡張正規表現に分類されます．メタキャラクタは，日本語
        も正確に認識します．


●正規表現

        　サポートしている正規表現は次の通り．

        １．c
        　メタキャラクタでない c は，その文字自身を意味する．

        ２．\c
        　以下の５通りの使い方がある．

                \t              タブ．
                \f              フォームフィード．
                \v              バーティカルタブ．
                \b              バックスペース．
                それ以外        c を通常の文字として扱う．

        ３．^
        　行の先頭を表す．行の先頭とは，検索するバッファの先頭か，改行文
        字の直後のことである．但し，全体の正規表現の先頭に指定されない場
        合は，通常の文字として扱われる．

        ４．$
        　行の末尾を表す．行の末尾とは，検索するバッファの末尾か，改行文
        字の直前のことである．但し，全体の正規表現の末尾に指定されない場
        合は，通常の文字として扱われる．

        ５．.
        　改行以外の任意の１文字を表す．全角文字も，１文字としてマッチす
        る．

        ６．[...]
        　[] 内に含まれる任意の１文字を表す．A-Z や あ-ん のような範囲指
        定も可能．

        ７．[^...]
        　[] 内に含まれる文字のどれとも一致しない任意の１文字を表す．範囲
        指定も可能．



                                  - 1 -                                 







        ８．r*
        　正規表現 r を０回以上繰返したものを表す．closure（閉包）．

        ９．r+
        　正規表現 r を１回以上繰り返したものを表す．posivite closure（正
        閉包）．

        １０．r?
        　正規表現 r の０回または１回を表す．

        １１．r1r2
        　正規表現 r1 に続いて r2 が現れることを表す．concatenation（連接）．

        １２．r1|r2
        　正規表現 r1 または r2 を表す．union（選択）．

        １３．(r)
        　正規表現 r を表す．


●構文規則

        rexp の構文規則は次の通り．

        line
                : expression
                | '^' expression
                | expression '$'
                | '^' expression '$'
                ;

        expression
                : /* empty */
                | term
                | term '|' expression
                ;

        term
                : term
                | factor term
                ;

        factor
                : primary
                | factor '*'
                | factor '+'
                | factor '?'
                ;

        primary
                : character_literal
                | '.'
                | character_class
                | negative_character_class
                | '(' expression ')'
                ;


                                  - 2 -                                 









●関数

        　関数プロトタイプは rexp.h に定義されている．正規表現のコンパイ
        ル方式には，タイプ１（単一の表現を指定），タイプ２（複数の表現を
        指定），タイプ３（複数の表現を分割して指定）の３通りの方法がある．
        照合は，いずれの場合も re_exec を使い，同じである．


        １．正規表現のコンパイル（タイプ１）

        uchar* re_comp(uchar* pat);

        ◆機能

        　pat で指定された正規表現を内部形式にコンパイルする．pat が NUL
        L の場合，直前にコンパイルされたものが使用される．

        ◆戻り値

        　NULL          正常終了
        　それ以外      エラーメッセージへのポインタ


        ２．正規表現のコンパイル（タイプ２）

        uchar* re_compv(uchar** pat)

        ◆機能

        　pat で指定された複数の正規表現を内部形式にコンパイルする．pat
        は main 関数の argv と同じ char ポインタの配列形式で，最後を NUL
        L で締めくくる．

        ◆戻り値

        　NULL          正常終了
        　それ以外      エラーメッセージへのポインタ



        ３．正規表現の指定開始（タイプ３）

        void re_init_pattern( void );

        ◆機能

        　複数の正規表現を，以下 re_add_pattern により個々に指定すること
        を宣言する．

        ◆戻り値

          なし




                                  - 3 -                                 








        ４．正規表現をリストに加える（タイプ３）

        unsigned re_add_pattern( uchar* );

        ◆機能

        　pat で指定された正規表現をコンパイルし，内部のリストに加える．

        ◆戻り値

        　パターンの id 番号（パターンを同定する１ビットが立っている）．



        ５．正規表現の指定終了（タイプ３）

        void re_end_pattern( void );

        ◆機能

        　re_add_pattern の終りを指定する．re_init_pattern, re_add_patte
        rn を使用した後は，必ずこの関数を呼ぶ必要がある．

        ◆戻り値

        　なし




        ６．正規表現の照合

        int re_exec(uchar* text);

        ◆機能

        　直前にコンパイルされた正規表現と text で指定されたバッファ内の
        行にマッチするものがあるか調べる．

        ◆戻り値

        　0             マッチしない
          0 以外        マッチした正規表現のリスト上の順番に対応するビッ
        トが立っている

        　例えば，1 番目と 3 番目に指定されたパターンと一致した場合は，5
         が返される．また，re_comp でコンパイルした場合は，戻り値は 0 ま
        たは 1 のみとなる．


●グローバル変数

        グローバル変数は rexp.h に定義されている．




                                  - 4 -                                 







        １．検索時英字の大文字小文字の区別

        int re_ignore_case;

        ◆内容

        　半角英字の大文字と小文字の区別をするかしないかを保持するグロー
        バル変数．

        ◆値

        　0             大文字と小文字の区別をする．
        　0 以外        大文字と小文字の区別をしない．


        ２．拡張エラー情報

        int re_errno;

        ◆内容

        　直前の関数の実行の際に発生したエラーを報告するグローバル変数．

        ◆値

        　RE_ERR_NONE           エラーはない

        　以下 re_comp() 時

        　RE_ERR_CCL_NUM        文字クラスのバッファが溢れた
        　RE_ERR_CCL_TERM       文字クラス指定の終端文字が見つからない
        　RE_ERR_MEMORY         メモリが足りない
        　RE_ERR_PAR            括弧の対応がおかしい
        　RE_ERR_SYNTAX         構文エラー

        　以下 re_exec() 時

        　RE_ERR_TABLE          NFA -> DFA 変換ワークテーブルが溢れた
        　RE_ERR_DFA_STAT       DFA の状態が多すぎてバッファが溢れた


●ノート

        　rexp は，高速化のために静的メモリを使っています．rexp.h に定義
        されているバッファのサイズはデータ領域が 64KB 以内に収まるギリギ
        リの値です．複雑な正規表現で，数 MB の巨大なテキストを検索すると
        バッファが溢れることがあるので，適宜大きな値に変更してください．
        特に，DFA 状態遷移テーブルには多くのメモリを必要としますので，DF
        A_TRANS_MAX には出来るだけ大きな値を指定してください（但し，DFA
        状態遷移テーブルが溢れてもキャッシュがききにくくなるだけで，エラ
        ーにはなりません）．

        　rexp は，MS-C V6.00，LSIC-86 V3.20，TC++ V1.00 で動作を確認して
        います．付属の srexp.lib と lrexp.lib は，それぞれ MS-C の small
         memory model，large memory model に対応したライブラリです．UN*X
         上の処理系への移植も，iskanji() さえ用意すれば簡単だと思います．


                                  - 5 -                                 








        　現在残されている問題点は，上記メモリの制約の他に，１．Boyer-Mo
        ore アルゴリズムの方法で，英字の大文字小文字を無視した検索をする
        場合，全角文字に対して適切な処理を行っていないので，例えば，"Ｕ"
         と "５" の区別が付かない，２．メタキャラクタ '^' と '$' が場所に
        依存している（慣習ではありますが），３．タグ付き正規表現がサポー
        トされていない，などあります．

        　著作権は特に主張しませんが，改変など行って再配布する場合は，フ
        ァイル先頭のコメントにその旨を書いてください．また，転載や配布は
        許可なしに行ってかまいません．もちろん，自作ソフトウェアに組み込
        んで発表されてもかまいません．但し，私はこのソフトウェアによる損
        害の責任は一切負いません．

                                  　飯塚　豊（ＤＵＤＥ）                
                                    Internet     dude@is.s.u-tokyo.ac.jp
                                    MASTERNET    AAC544                 
                                    NIFTY-Serve  PFF01344               


        ◆参考文献

            A.V. Aho, R. Sethi and J.D. Ullman [1986]
            Compilers Principles, Techniques, and Tools
            Addison-Wesley

            石畑　清 [1989]
            アルゴリズムとデータ構造 
            岩波書店

            A.V. Aho, J.E. Hopcroft and J.D. Ullman [1974]
            The Design and Analysis of Computer Algorithms
            Addison-Wesley

























                                  - 6 -                                 


