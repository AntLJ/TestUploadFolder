/*
 * Copyright (C) INCREMENT P CORP. All Rights Reserved.
 *
 * THIS SOFTWARE IS PROVIDED BY INCREMENT P CORP., WITHOUT WARRANTY OF
 * ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
 * AND NONINFRINGEMENT.
 *
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDER BE LIABLE FOR ANY
 * CLAIM, DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING
 * OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.
*/

// SINDY2ROADCODE.cpp: SINDY2ROADCODE ÉNÉâÉXÇÃÉCÉìÉvÉäÉÅÉìÉeÅ[ÉVÉáÉì
//
//////////////////////////////////////////////////////////////////////

#include "SINDY2ROADCODE.h"
#include "SINDY2INCODE.h"
#include "WKHString.h"

SINDY2ROADCODE::SINDY2ROADCODE(SINDY2INHWYINFO *cHwyInfo) :
SINDY2INHWY(cHwyInfo)
{

}

SINDY2ROADCODE::~SINDY2ROADCODE()
{

}

HRESULT SINDY2ROADCODE::Convert()
{
	HRESULT hr;
	const char *func = "SINDY2ROADCODE::Convert";

#ifdef	_DEBUG
	debug = 0;
#endif
	for (GDBOBJITER aIter = mpHwyInfo->eRoadCodeList.begin(); aIter != mpHwyInfo->eRoadCodeList.end(); aIter++)
	{
#ifdef	_DEBUG
		std::cerr << "Creating road.code.doc... : " << ++debug << "/" << mpHwyInfo->eRoadCodeList.size() << "\r";
#endif
		_IRowPtr ipRow = aIter->second;

		static long aLineClassFieldIndex = ipRow->Fields->_FindField(_bstr_t(sindy::road_code_list::LINECLASS_C.c_str()));
		long aLineClass = ipRow->GetValue(aLineClassFieldIndex);

		static long aRoadCodeFieldIndex = ipRow->Fields->_FindField(_bstr_t(sindy::road_code_list::ROAD_CODE.c_str()));
		long aRoadCode = ipRow->GetValue(aRoadCodeFieldIndex);

		CComVariant vaName1, vaName2, vaName3, vaYomi1, vaYomi2, vaYomi3;
		if (FAILED(hr = GDBGetValue(ipRow, sindy::road_code_list::NAME_KANJI, &vaName1))) return hr;
		if (FAILED(hr = GDBGetValue(ipRow, sindy::road_code_list::NAME_YOMI, &vaYomi1))) return hr;
		if (FAILED(hr = GDBGetValue(ipRow, sindy::road_code_list::WORK_KANJI, &vaName2))) return hr;
		if (FAILED(hr = GDBGetValue(ipRow, sindy::road_code_list::WORK_YOMI, &vaYomi2))) return hr;
		if (FAILED(hr = GDBGetValue(ipRow, sindy::road_code_list::DISPLAY_KANJI, &vaName3))) return hr;
		if (FAILED(hr = GDBGetValue(ipRow, sindy::road_code_list::DISPLAY_YOMI, &vaYomi3))) return hr;

		std::string aName1(""), aName2(""), aName3(""), aYomi1(""), aYomi2(""), aYomi3("");
		if (vaName1.vt != VT_NULL && vaName1.vt != VT_EMPTY)
		{
			vaName1.ChangeType(VT_BSTR);
			aName1 = COLE2T(vaName1.bstrVal);
			if (aName1 == " " || aName1 == "Å@") aName1 = "";
		}
		if (vaName2.vt != VT_NULL && vaName2.vt != VT_EMPTY)
		{
			vaName2.ChangeType(VT_BSTR);
			aName2 = COLE2T(vaName2.bstrVal);
			if (aName2 == " " || aName2 == "Å@") aName2 = "";
		}
		if (vaName3.vt != VT_NULL && vaName3.vt != VT_EMPTY)
		{
			vaName3.ChangeType(VT_BSTR);
			aName3 = COLE2T(vaName3.bstrVal);
			if (aName3 == " " || aName3 == "Å@") aName3 = "";
		}
		if (vaYomi1.vt != VT_NULL && vaYomi1.vt != VT_EMPTY)
		{
			vaYomi1.ChangeType(VT_BSTR);
			aYomi1 = COLE2T(vaYomi1.bstrVal);
			if (aYomi1 == " " || aYomi1 == "Å@") aYomi1 = "";
		}
		if (vaYomi2.vt != VT_NULL && vaYomi2.vt != VT_EMPTY)
		{
			vaYomi2.ChangeType(VT_BSTR);
			aYomi2 = COLE2T(vaYomi2.bstrVal);
			if (aYomi2 == " " || aYomi2 == "Å@") aYomi2 = "";
		}
		if (vaYomi3.vt != VT_NULL && vaYomi3.vt != VT_EMPTY)
		{
			vaYomi3.ChangeType(VT_BSTR);
			aYomi3 = COLE2T(vaYomi3.bstrVal);
			if (aYomi3 == " " || aYomi3 == "Å@") aYomi3 = "";
		}

		RoadCodeDoc aRoadCodeDoc;
		// [Bug6456] É\Å[ÉgäÓèÄÇïœÇ¶ÇÈÇΩÇﬂÅAsindy::road_code_list::lineclass_cÇ≈ÇÕÇ»Ç≠ÅAINHwySchemaÇ≈íËã`ÇµÇΩílÇäiî[Ç∑ÇÈÇÊÇ§Ç…ïœçX
		aRoadCodeDoc.eClass				= Sindy2INCode(in::schema::road_code_doc::line_class::tLineClass, aLineClass);
		aRoadCodeDoc.eClassForSiRiUS	= Sindy2INCode(in::schema::road_code_doc::line_class::tLineClassForSiRiUS, aLineClass);
		aRoadCodeDoc.eRoadCode  = aRoadCode;
		aRoadCodeDoc.eName  = aName1;
		aRoadCodeDoc.eYomi  = aYomi1;
		aRoadCodeDoc.eName2 = aName2;
		aRoadCodeDoc.eYomi2 = aYomi2;
		aRoadCodeDoc.eName3 = aName3;
		aRoadCodeDoc.eYomi3 = aYomi3;

		mRoadCodeDocArray.insert(aRoadCodeDoc);
	}

#ifdef	_DEBUG
	std::cerr << std::endl;
#endif

	return S_OK;
}

HRESULT SINDY2ROADCODE::Write(std::string cFileName, long cType)
{
	const char *func = "SINDY2ROADCODE::Write";

	ofstream aFile(cFileName.c_str(), ios::binary);
	if (! aFile.is_open()) GDBERROR2(E_ACCESSDENIED, func);

	long aPrevClass = 0;
	for (std::multiset<RoadCodeDoc,lessRoadCodeDoc>::iterator aIter = mRoadCodeDocArray.begin(); aIter != mRoadCodeDocArray.end(); aIter++)
	{
		// ÉtÉFÉäÅ[çqòHÇ∆ÇªÇÍà»äOÇÃîªï 
		switch (cType)
		{
			using namespace in::schema::road_code_doc::file_type;
			case road_code:
			case road_code_highway:
			case road_code_display:
				if (aIter->eClass == in::schema::road_code_doc::line_class::ferry) continue;
				break;
			case ferry_code:
				if (aIter->eClass != in::schema::road_code_doc::line_class::ferry) continue;
				break;
			default:
				ATLASSERT(0);
		}

		// ä«óùícëÃñºÅiíºëOÇÃÉåÉRÅ[ÉhÇÃä«óùícëÃñºÇ∆àŸÇ»ÇÈéûÇæÇØèoóÕÇ∑ÇÈÅj
		if (! aPrevClass || aPrevClass != aIter->eClass)
		{
			aFile << SINDY2INCODE::SJIS2EUC(LineClass2OrgName(aIter->eClass).c_str());
			aPrevClass = aIter->eClass;
		}

		// òHê¸ÉRÅ[Éh
		aFile << "\t";
		aFile.width(6); aFile.fill('0');
		aFile << std::dec << aIter->eRoadCode;

		// òHê¸ñºèÃÅEì«Ç›
		switch (cType)
		{
			using namespace in::schema::road_code_doc::file_type;
			case road_code:
			case ferry_code:
				aFile << "\t";
				aFile << SINDY2INCODE::SJIS2EUC(aIter->eName.c_str());
				if (aIter->eYomi.size())
				{
					aFile << "\t";
					aFile << SINDY2INCODE::SJIS2EUC(aIter->eYomi.c_str());
				}
				break;
			case road_code_highway:
				aFile << "\t";
				aFile << SINDY2INCODE::SJIS2EUC(aIter->eName2.c_str());
				aFile << "\t";
				aFile << SINDY2INCODE::SJIS2EUC(aIter->eYomi2.c_str());
				break;
			case road_code_display:
				aFile << "\t";
				aFile << SINDY2INCODE::SJIS2EUC(aIter->eName3.c_str());
				aFile << "\t";
				aFile << SINDY2INCODE::SJIS2EUC(aIter->eYomi3.c_str());
				break;
		}

		aFile << std::endl;
	}

	return S_OK;
}

HRESULT SINDY2ROADCODE::WriteForSirius(std::string cFileName, long cFormat)
{
	const char *func = "SINDY2ROADCODE::WriteForSirius";

	ofstream aFile(cFileName.c_str(), ios::binary);
	if (! aFile.is_open()) GDBERROR2(E_ACCESSDENIED, func);

	long aPrevClass = 0;
	for (std::multiset<RoadCodeDoc,lessRoadCodeDoc>::const_iterator aIter = mRoadCodeDocArray.begin(); aIter != mRoadCodeDocArray.end(); aIter++)
	{
		// ÉtÉFÉäÅ[çqòHÇÕèoóÕÇµÇ»Ç¢
		if (aIter->eClassForSiRiUS == in::schema::road_code_doc::line_class::ferry) { continue; }

		// äXìπñºÇÕèoóÕÇµÇ»Ç¢
		if (aIter->eClassForSiRiUS == in::schema::road_code_doc::line_class::street) { continue; }

		if (cFormat == in::schema::road_code_doc::file_format::roadtype)
		{
			// ìØÇ∂ä«óùícëÃñºÇèoóÕÇµÇ»Ç¢
			if (aPrevClass != 0 && aPrevClass == aIter->eClassForSiRiUS) { continue; }
			aPrevClass = aIter->eClassForSiRiUS;
		}

		// ä«óùícëÃÉRÅ[Éh
		aFile << aIter->eRoadCode/10000;

		std::pair<std::string, std::string> aNamePair = divideByCaseArc(aIter->eName);
		std::pair<std::string, std::string> aYomiPair = divideByCaseArc(aIter->eYomi);

		switch (cFormat)
		{
			using namespace in::schema::road_code_doc::file_format;
			case roadtype:
				// ä«óùícëÃñº
				aFile << "\t";
				aFile << SINDY2INCODE::SJIS2EUC(LineClass2OrgName(aIter->eClassForSiRiUS).c_str());

				// ä«óùícëÃñºì«Ç›
				aFile << "\t";
				aFile << SINDY2INCODE::SJIS2EUC(LineClass2OrgYomi(aIter->eClassForSiRiUS).c_str());
				break;

			case roadline:
				// òHê¸ÉVÅ[ÉPÉìÉXî‘çÜ
				aFile << "\t";
				aFile << aIter->eRoadCode%10000;

				// òHê¸ñºèÃ
				aFile << "\t";
				aFile << SINDY2INCODE::SJIS2EUC(aNamePair.first.c_str());

				// òHê¸ñºèÃì«Ç›
				aFile << "\t";
				aFile << SINDY2INCODE::SJIS2EUC(aYomiPair.first.c_str());

				// òHê¸ï‚ë´ñºèÃ
				aFile << "\t";
				if (aNamePair.second.size())
				{
					aFile << SINDY2INCODE::SJIS2EUC(aNamePair.second.c_str());
				}

				// òHê¸ï‚ë´ñºèÃì«Ç›
				aFile << "\t";
				if (aNamePair.second.size())
				{
					aFile << SINDY2INCODE::SJIS2EUC(aYomiPair.second.c_str());
				}

				// òHê¸íZèkñºèÃ
				aFile << "\t";
				aFile << SINDY2INCODE::SJIS2EUC(shortenName(aNamePair.first, "é©ìÆé‘ìπ", "ìπ").c_str());

				// òHê¸íZèkñºèÃì«Ç›
				aFile << "\t";
				aFile << SINDY2INCODE::SJIS2EUC(shortenName(aYomiPair.first, "ÉWÉhÉEÉVÉÉÉhÉE", "ÉhÉE").c_str());
				break;

			default:
				ATLASSERT(0);
		}
		aFile << std::endl;
	}
			
	return S_OK;
}


std::string SINDY2ROADCODE::LineClass2OrgName(long cLineClass)
{
	const char *func = "SINDY2ROADCODE::LineClass2OrgName";
	std::string aOrgName;

	switch (cLineClass)
	{
		using namespace in::schema::road_code_doc::line_class;
		case ferry:				aOrgName = "ÉtÉFÉäÅ[çqòH";			break;
		case street:			aOrgName = "äXìπñº";				break;
		case ordinary_tollroad:	aOrgName = "àÍî óLóøìπòH";			break;
		case highway:			aOrgName = "çÇë¨ìπòH";				break;
		case tollroad:			aOrgName = "óLóøìπòH";				break;
		case metropolis:		aOrgName = "éÒìsçÇë¨ìπòH";			break;
		case hanshin:			aOrgName = "ç„ê_çÇë¨ìπòH";			break;
		case nagoya:			aOrgName = "ñºå√âÆìsésçÇë¨ìπòH";	break;
		case fukuoka:			aOrgName = "ïüâ™ìsésçÇë¨ìπòH";		break;
		case kitakyushu:		aOrgName = "ñkã„èBìsésçÇë¨ìπòH";	break;
		case hiroshima:			aOrgName = "çLìáçÇë¨ìπòH";			break;
		case kyouto:			aOrgName = "ãûìsçÇë¨ìπòH";			break;
		default: GDBERROR2(E_NOINTERFACE, func);
	}

	return aOrgName;
}

std::string SINDY2ROADCODE::LineClass2OrgYomi(long cLineClass)
{
	const char *func = "SINDY2ROADCODE::LineClass2OrgYomi";
	std::string aOrgYomi;

	switch (cLineClass)
	{
		using namespace in::schema::road_code_doc::line_class;
		case ferry:				aOrgYomi = "ÉtÉFÉäÅ[ÉRÉEÉç";						break;
		case street:			aOrgYomi = "ÉJÉCÉhÉEÉÅÉC";							break;
		case ordinary_tollroad:	aOrgYomi = "ÉCÉbÉpÉìÉÜÉEÉäÉáÉEÉhÉEÉç";				break;
		case highway:			aOrgYomi = "ÉRÉEÉ\ÉNÉhÉEÉç";						break;
		case tollroad:			aOrgYomi = "ÉÜÉEÉäÉáÉEÉhÉEÉç";						break;
		case metropolis:		aOrgYomi = "ÉVÉÖÉgÉRÉEÉ\ÉNÉhÉEÉç";					break;
		case hanshin:			aOrgYomi = "ÉnÉìÉVÉìÉRÉEÉ\ÉNÉhÉEÉç";				break;
		case nagoya:			aOrgYomi = "ÉiÉSÉÑÉgÉVÉRÉEÉ\ÉNÉhÉEÉç";				break;
		case fukuoka:			aOrgYomi = "ÉtÉNÉIÉJÉgÉVÉRÉEÉ\ÉNÉhÉEÉç";			break;
		case kitakyushu:		aOrgYomi = "ÉLÉ^ÉLÉÖÉEÉVÉÖÉEÉgÉVÉRÉEÉ\ÉNÉhÉEÉç";	break;
		case hiroshima:			aOrgYomi = "ÉqÉçÉVÉ}ÉRÉEÉ\ÉNÉhÉEÉç";				break;
		case kyouto:			aOrgYomi = "ÉLÉáÉEÉgÉRÉEÉ\ÉNÉhÉEÉç";				break;
		default: GDBERROR2(E_NOINTERFACE, func);
	}

	return aOrgYomi;
}

std::string SINDY2ROADCODE::shortenName(std::string cName, std::string cBefore, std::string cAfter)
{
	std::string aName = cName;

	while(1)
	{
		std::string::size_type aIndex = aName.find(cBefore);
		if (aIndex == std::string::npos) { break; }
		aName.replace(aIndex, cBefore.size(), cAfter);
	}

	return aName;
}

std::pair<std::string, std::string> SINDY2ROADCODE::divideByCaseArc(std::string cStr)
{
	USES_CONVERSION;

	std::wstring aSrc = A2W(cStr.c_str());
	std::wstring aExternal = aSrc;
	std::wstring aInternal;

	// ññîˆÇ…'Åj'Ç™Ç†ÇÈÇ©ÅH
	std::wstring::size_type aCloseIndex = aSrc.find_last_of(L"Åj");
	if (aCloseIndex != std::wstring::npos && aCloseIndex == aSrc.size()-1)
	{
		// 'Åi'Ç™Ç†ÇÈÇ©ÅH
		std::wstring::size_type aOpenIndex = aSrc.find_last_of(L"Åi");
		if (aOpenIndex != std::wstring::npos)
		{
			aExternal.erase(aOpenIndex, std::wstring::npos);
			aInternal.assign(aSrc, aOpenIndex+1, aCloseIndex-aOpenIndex-1);
		}
	}

	return std::make_pair(W2A(aExternal.c_str()), W2A(aInternal.c_str()));
}

